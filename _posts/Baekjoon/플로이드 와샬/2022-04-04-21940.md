---
layout: single
title: "[백준] 21940 가운데에서 만나기 c++"

categories:
  - Baekjoon

tags:
  - 알고리즘
  - 백준
  - c++
  - 플로이드 와샬

author_profile: true # 왼쪽부분 프로필을 띄울건지

header:
  overlay_image: https://images.unsplash.com/photo-1501785888041-af3ef285b470?ixlib=rb-1.2.1&ixid=eyJhcHBfaWQiOjEyMDd9&auto=format&fit=crop&w=1350&q=80
  overlay_filter: 0.5 # 투명도

# table of contents
toc: true # 오른쪽 부분에 목차를 자동 생성해준다.
toc_label: " table of content" # toc 이름 설정
toc_icon: "bars" # 아이콘 설정
toc_sticky: true # 마우스 스크롤과 함께 내려갈 것인지 설정
---

문제 링크 [https://www.acmicpc.net/problem/21940](https://www.acmicpc.net/problem/21940)

## 문제

준형이는 내일 친구들을 만나기로 했다. 준형이와 친구들은 서로 다른 도시에 살고 있다.

도시를 연결하는 도로는 일방 통행만 있어서 도시 $A_{i}$에서 도시 $B_{i}$로 가는 시간과 도시 $B_{i}$에서 도시 $A_{i}$로 가는 시간이 다를 수 있다.

준형이와 친구들은 아래 조건을 만족하는 도시 $X$를 선택하여 거기서 만나려고 한다.

왕복시간은 자신이 살고 있는 도시에서 도시 $X$로 이동하는 시간과 도시 $X$에서 다시 자신이 살고 있는 도시로 이동하는 시간을 합한 것이다.
준형이와 친구들이 도로를 이용하여 갈 수 있는 도시만 선택한다.
준형이와 친구들의 왕복시간 들 중 최대가 최소가 되는 도시 $X$를 선택한다.
준형이와 친구들이 이동할 수 있는 도시가 최소한 하나 이상이 있음을 보장한다.
도시가 많다보니 계산하기 힘들다. 준형이와 친구들을 대신하여 도시 $X$를 알려주자.

## 입력

첫째 줄에는 지역의 개수 n (1 ≤ n ≤ 100)과 예은이의 수색범위 m (1 ≤ m ≤ 15), 길의 개수 r (1 ≤ r ≤ 100)이 주어진다.

둘째 줄에는 n개의 숫자가 차례대로 각 구역에 있는 아이템의 수 t (1 ≤ t ≤ 30)를 알려준다.

세 번째 줄부터 r+2번째 줄 까지 길 양 끝에 존재하는 지역의 번호 a, b, 그리고 길의 길이 l (1 ≤ l ≤ 15)가 주어진다.

## 출력

예은이가 얻을 수 있는 최대 아이템 개수를 출력한다.

## 풀이 과정

자신에서 자신으로 갈 수 없으니, i == j 일 때를 제외한 나머지 부분들은 무한대로 초기 설정한다. 그리고 num 배열에 각 정점에서 얻을 수 있는 아이템이 몇 개인지 입력 받는다. 플로이드 와샬을 시행했을 때, 결과는 아래 사진처럼 나오게 되는데, 여기서의 숫자들은 각 노드에서 다른 노드를 갈 때 길의 길이가 얼마인지 알려주는 숫자들이다. 수색범위가 m이니까 각 노드에서 갈 때를 비교하여 m 이상인 숫자들은 도달할 수 없는 정점이라는 뜻이니 continue로 넘어가준다.

![14938](../../images/14938.jpg){: width="500" height="300"}

```c++
#include <vector>
#include <algorithm>
#include <iostream>
#include <cstring>
#include <stack>
#include <queue>
#include <string>
#define _CRT_SECURE_NO_WARNINGS
#pragma warning(disable : 4996)
using namespace std;

int n, m, r, x, y, z;
int num[101];
int arr[101][101];
const int INF = 1e9;

void floyd() {
  for (int k = 1; k <= n; k++) { // 경유지
    for (int i = 1; i <= n; i++) { // 출발지점
      for (int j = 1; j <= n; j++) { // 도착지점
        if (arr[i][j] > arr[i][k] + arr[k][j]) {
            arr[i][j] = arr[i][k] + arr[k][j];
        }
      }
    }
  }
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(NULL); cout.tie(NULL);

    cin >> n >> m >> r;
    // 플로이드 와샬 초기설정
    for (int i = 1; i <= n; i++) {
    	for (int j = 1; j <= n; j++) {
    		if (i != j) arr[i][j] = INF;
    	}
    }
    for (int i = 1; i <= n; i++) cin >> num[i];
    for (int i = 0; i < r; i++) {
    	cin >> x >> y >> z;
    	arr[x][y] = z;
    	arr[y][x] = z;
    }
    floyd();

    int res = 0;
    for (int i = 1; i <= n; i++) {
    	int sum = 0;
    	for (int j = 1; j <= n; j++) {
    		if (arr[i][j] > m) continue;
    		sum += num[j];
    	}
    	res = max(res, sum);
    }
    cout << res;
}
```
